<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>IoT Asset Tracker</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: "Segoe UI", sans-serif;
        display: flex;
        height: 100vh;
        overflow: hidden;
      }
      #graph-container {
        flex: 2;
        background: #f0f0f0;
        position: relative;
      }
      #canvas-grid {
        width: 100%;
        height: 100%;
        cursor: grab;
        display: block;
      }
      #tag-list {
        flex: 1;
        background: #fff;
        border-left: 1px solid #ddd;
        overflow-y: auto;
        padding: 20px;
        display: flex;
        flex-direction: column;
      }
      .tag-card {
        background-color: #fdfdfd;
        border: 1px solid #e5e5e5;
        border-radius: 14px;
        padding: 16px 18px;
        margin-bottom: 16px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.06);
        transition: box-shadow 0.3s ease, transform 0.2s ease;
        cursor: pointer;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .tag-card:hover {
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        transform: translateY(-2px);
        background-color: #ffffff;
      }

      .tag-card .tag-id {
        font-weight: 600;
        font-size: 16px;
        color: #111;
        margin-bottom: 4px;
      }

      .tag-card .coord-label {
        font-size: 13px;
        font-weight: 500;
        color: #888;
      }

      .tag-card .coord-value {
        font-size: 14px;
        color: #333;
        font-variant-numeric: tabular-nums;
      }
      .highlight {
        outline: 3px solid #3498db;
      }
      #reset-button {
        margin-top: auto;
        padding: 12px;
        border: none;
        border-radius: 10px;
        background: #007aff;
        color: white;
        font-weight: 500;
        font-size: 15px;
        cursor: pointer;
        transition: background 0.2s ease;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
      }

      #reset-button:hover {
        background: #005fd1;
      }
      .tooltip {
        position: absolute;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 6px 8px;
        border-radius: 4px;
        pointer-events: none;
        font-size: 12px;
      }
    </style>
  </head>
  <body>
    <div id="graph-container">
      <canvas id="canvas-grid"></canvas>
      <div id="tooltip" class="tooltip" style="display: none"></div>
    </div>
    <div id="tag-list">
      <!-- Cards will be injected here -->
      <button id="reset-button">Reset View</button>
    </div>

    <script>
      const canvas = document.getElementById("canvas-grid");
      const ctx = canvas.getContext("2d");
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      let scale = 100;
      let originX = canvas.width / 2;
      let originY = canvas.height / 2;
      let isDragging = false;
      let dragStart = { x: 0, y: 0 };
      let selectedTag = null;
      let beaconPositions = {};
      const tags = {};
      const tooltip = document.getElementById("tooltip");
      let hasFittedOnce = false;

      function worldToCanvas(x, y) {
        return {
          x: originX + x * scale,
          y: originY - y * scale,
        };
      }

      function canvasToWorld(x, y) {
        return {
          x: (x - originX) / scale,
          y: (originY - y) / scale,
        };
      }

      canvas.addEventListener("mousedown", (e) => {
        isDragging = true;
        dragStart = { x: e.offsetX, y: e.offsetY };
        canvas.style.cursor = "grabbing";
      });

      canvas.addEventListener("mouseup", () => {
        isDragging = false;
        canvas.style.cursor = "grab";
      });

      canvas.addEventListener("mousemove", (e) => {
        if (isDragging) {
          originX += e.offsetX - dragStart.x;
          originY += e.offsetY - dragStart.y;
          dragStart = { x: e.offsetX, y: e.offsetY };
        }
      });

      canvas.addEventListener("wheel", (e) => {
        e.preventDefault();
        const zoom = e.deltaY < 0 ? 1.1 : 0.9;
        const mouse = canvasToWorld(e.offsetX, e.offsetY);
        scale *= zoom;
        originX = e.offsetX - mouse.x * scale;
        originY = e.offsetY + mouse.y * scale;
      });

      canvas.addEventListener("click", (e) => {
        const mouse = canvasToWorld(e.offsetX, e.offsetY);
        for (const [id, t] of Object.entries(tags)) {
          const dx = t.x - mouse.x;
          const dy = t.y - mouse.y;
          if (Math.sqrt(dx * dx + dy * dy) < 0.2) {
            selectedTag = id;
            focusOnTag(id);
            showTooltip(id, t);
            highlightCard(id);
            break;
          }
        }
      });

      document.getElementById("reset-button").addEventListener("click", () => {
        fitToBeacons();
      });

      function showTooltip(id, t) {
        const { x, y } = worldToCanvas(t.x, t.y);
        tooltip.style.left = `${x + 10}px`;
        tooltip.style.top = `${y - 30}px`;
        tooltip.innerText = `${id}\nX: ${t.x}, Y: ${t.y}, Z: ${t.z}`;
        tooltip.style.display = "block";
        setTimeout(() => (tooltip.style.display = "none"), 2000);
      }

      function highlightCard(tagId) {
        document.querySelectorAll(".tag-card").forEach((card) => {
          card.classList.toggle("highlight", card.dataset.id === tagId);
        });
      }

      function renderTagList() {
        const list = document.getElementById("tag-list");
        list.querySelectorAll(".tag-card").forEach((e) => e.remove());
        Object.entries(tags).forEach(([id, t]) => {
          const div = document.createElement("div");
          div.className = "tag-card";
          div.dataset.id = id;
          div.innerHTML = `
            <div class="tag-id">${id}</div>
            <div><span class="coord-label">X</span>: <span class="coord-value">${t.x}</span></div>
            <div><span class="coord-label">Y</span>: <span class="coord-value">${t.y}</span></div>
            <div><span class="coord-label">Z</span>: <span class="coord-value">${t.z}</span></div>
            `;
          div.onclick = () => {
            selectedTag = id;
            focusOnTag(id);
            showTooltip(id, t);
            highlightCard(id);
          };
          list.insertBefore(div, document.getElementById("reset-button"));
        });
      }

      function fitToBeacons() {
        const xs = Object.values(beaconPositions).map((b) => b[0]);
        const ys = Object.values(beaconPositions).map((b) => b[1]);
        const minX = Math.min(...xs),
          maxX = Math.max(...xs);
        const minY = Math.min(...ys),
          maxY = Math.max(...ys);
        const padding = 1;
        const roomWidth = maxX - minX + padding * 2;
        const roomHeight = maxY - minY + padding * 2;

        scale = Math.min(canvas.width / roomWidth, canvas.height / roomHeight);
        originX = canvas.width / 2 - ((minX + maxX) / 2) * scale;
        originY = canvas.height / 2 + ((minY + maxY) / 2) * scale;
      }

      function focusOnTag(id) {
        const tag = tags[id];
        if (!tag) return;
        originX = canvas.width / 2 - tag.x * scale;
        originY = canvas.height / 2 + tag.y * scale;
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = "#ddd";
        const step = scale;
        for (let x = originX % step; x < canvas.width; x += step) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, canvas.height);
          ctx.stroke();
        }
        for (let y = originY % step; y < canvas.height; y += step) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(canvas.width, y);
          ctx.stroke();
        }

        // Beacons
        ctx.fillStyle = "#e74c3c";
        for (const [id, b] of Object.entries(beaconPositions)) {
          const { x, y } = worldToCanvas(b[0], b[1]);
          ctx.beginPath();
          ctx.arc(x, y, 6, 0, 2 * Math.PI);
          ctx.fill();
          ctx.fillText(id, x + 8, y - 8);
        }

        // Tags
        for (const [id, t] of Object.entries(tags)) {
          const { x, y } = worldToCanvas(t.x, t.y);
          ctx.beginPath();
          ctx.arc(x, y, 8, 0, 2 * Math.PI);
          ctx.fillStyle = id === selectedTag ? "#2ecc71" : "#3498db";
          ctx.fill();
          ctx.stroke();
          ctx.fillStyle = "#000";
          ctx.fillText(id, x + 10, y - 10);
        }

        window.addEventListener("resize", () => {
          const oldWidth = canvas.width;
          const oldHeight = canvas.height;
          const newWidth = canvas.offsetWidth;
          const newHeight = canvas.offsetHeight;

          // Adjust origin based on how much the canvas grew/shrank
          originX += (newWidth - oldWidth) / 2;
          originY += (newHeight - oldHeight) / 2;

          canvas.width = newWidth;
          canvas.height = newHeight;
        });

        requestAnimationFrame(draw);
      }

      async function fetchData() {
        const beaconRes = await fetch("/beacons");
        beaconPositions = await beaconRes.json();

        if (!hasFittedOnce && Object.keys(beaconPositions).length > 0) {
          fitToBeacons();
          hasFittedOnce = true;
        }

        const res = await fetch("/positions");
        const data = await res.json();

        data.forEach((p) => {
          tags[p.id] = { x: p.x, y: p.y, z: p.z };
        });

        renderTagList();
      }

      // Initial run
      fetchData(); // ‚úÖ Run once on load
      setInterval(fetchData, 1000); // üîÅ Then every second
      requestAnimationFrame(draw); // üåÄ Start the draw loop
    </script>
  </body>
</html>
